<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta http-equiv="X-UA-Compatible" content="ie=edge" />
        <link rel="shortcut icon" type="image/png" href="./img/favicon.png" />
        <link rel="stylesheet" type="text/css" href="./main.css" />
        <link rel="stylesheet" type="text/css" href="./documentation.css" />
        <script src="./behavior.js"></script>
        <title>InsidAR - Location based experiences</title>

        <style>
            hr{
                color: black;
            }
        </style>
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="./index.html"><img src="./img/logo_2_hor.png"/></a>
            </div>
        </header>
        <h1>Documentation</h1>
        <div class="side-nav">
            <a onclick="switchView('how-it-works')">-Tutorial & How it works</a>
            <a onclick="switchView('limitations-and-privacy')">-Limitations & Privacy</a>
            <a onclick="onUnitySDKClick()">+Unity SDK reference</a>
            <div id="unity-sdk-dropdown" class="dropdown" style="display: none">
                <a href="#insidar-manager">--InsidAR Manager</a>
                <a href="#scan-manager">--Scan Manager</a>
                <a href="#network-manager">--Network Manager</a>
                <a href="#process-response">--ProcessResponse</a>
            </div>
        </div>

        <div class="main-body">
            <div class="how-it-works">
                <h2>How it works</h2>
                <p>
                    We do localization by basically trying to match a small 3D scan the client makes inside the initial,
                    bigger scan, you made using <b>InsidAR ScanApp</b>.
                </p>
                <h3>1. Main Scan</h3>
                <p>It all starts with the main scan. You need to store the scans inside your location using InsidAR ScanApp on our servers. Please take into the consideration the <a>Limitations</a>.</a></p>
                <h3>2. Client App</h3>
                <p>
                    The client app should use <b>InsidAR Unity Package</b> in order to be able to grab the 3D data
                    inside your app as well. The translation/rotation offset between your scan and the main scan is by calling our API.
                    The Unity package(<a>Unity SDK reference</a>) is able to:
                </p>
                <ul>
                    <li>Provide the InsidAR Scan</li>
                    <li>Offer methods for API Calls: Localization, Persistent Anchors CRUD, Maps CRUD </li>
                </ul>
                <h3>3. Dashboard</h3>
                <p>
                    Right now our dashboard is at beginning. It can be used to visualize scanned maps and to move/place
                    and see anchors inside a map. More features will be available soon.
                </p>
                <h2>Getting Started</h2>
                <p><i>** InsidAR Unity Package works over ARCore/ARKit 's SLAM system. For this we are actually use Unity's wrapper, ARFoundation. It is still in preview so future updates might be breaking for InsidAR. We used <b>Unity 2018+</b> with <b>ARFoundation 1.5.0 preview-5</b> and <b>ARCore 2.1.0 preview 5</b>. In case you try on other versions and it's throwing errors please <b>Contact us</b> and we will try to offer a working version as soon as possible.**</i></p>
                <h3>Open Unity Package</h3>
                <p>The InsidAR Unity Package contains all you need to make a localization app. Check out the example scene for how it works or follow the next steps in a new project!</p>
                <ul>
                    <li>Open new Unity Project and import InsidAR package</li>
                    <li>Import ARFoundation(1.5.0 preview 5) and ARCore(2.1.0 preview 5) from Package Manager</li>
                    <li>Switch platform to Android</li>
                    <li>Check 'Allow unsafe code' inside player settings. We do this since it's required for getting the image from AR Camera.</li>
                    <li>If on Android set min API Level to at least 24 and set a correct package name.</li>
                    <li>Add ARSession and ARSessionOrigin to scene (and delete the default camera)</li>
                    <hr/>
                    Either:
                    <li>Add ARSession Origin to scene. Add ARPointCloudManager component to it. Select AR Camera and set tag to MainCamera</li>
                    <li>Or - Drag our ARSessionOrigin to scene</li>
                    <hr/>
                    <li>Drag the InsidARManager prefab in the scene</li>
                    <li>Drag ARPointCloudManager to the empty attribute inside FeaturePointExtractor script of InsidARManager</li>
                    <li>Drag the ARCamera under ARSessionOrigin inside InsidARManager - ComputerVision - CameraImageManager</li>
                    <li>Setup the API Key inside InsidARManager script</li>
                </ul>
                <p> That's it! Now you should be able to scan (<b>FeaturePointExtractor</b>) and API endpoints(<b>NetworkManager</b>)</p>

                <h2>Tutorials</h2>
                <iframe class="yt-video" src="https://www.youtube.com/embed/AhxCkjKoLBM" frameborder="0"
                    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


            </div>
            <div class="limitations-and-privacy" style="display:none">
                <h2>Limitations</h2>
                <p>
                    3D scans are awesome. For the scan we've added our layers of algorithms over ARCore and ARKit's SLAM
                    enginges. Therefore most limitations can also be found in those libraries. Although the scan is
                    quite consistent, there are a few points where scans can be just noise, become a source of future
                    errors or simply ambiguity.
                </p>
                <p>Before and while scanning, please don't just orbit around, but also move. Translation is important for accurately measuring 3D points positions.</p>
                <img src="./img/rotate.PNG" />
                <h3>Recommended thresholds</h3>
                <p>
                    The parent scan should at least 2.000 points, while the candidate scans at least 750.
                </p>
                <h3>Blurred or no-contrast images</h3>
                <p>
                    As we work with contrast points mostly, we bypass low contrast images, such as white walls, or blurred ones.
                </p>
                <h3>Glass and Reflections</h3>
                <p>
                    Reflections, mirrors, windows and so one are not only invisible to the Scanner but also add random
                    geometry based on the shine and the image they reflect.
                </p>
                <img src="./img/shiny.PNG" />
                <h3>Repetitive patterns</h3>
                <p>
                    As we use color and structure, if two areas of the same building look almost the same, they will
                    look the same for the algorithms as well.
                </p>
                <img src="./img/pattern.PNG" />
                <h3>Big visual changes</h3>
                <p>
                    If a scan is stored but big changes happen, such as moving a whole isle in a store, painting the
                    walls etc, the recognition could be less exact or even stop working.
                </p>
                <h2>Privacy</h2>
                <h3>Fine matching</h3>
                <p>For each location we store a 3D colored point cloud such as this one below. For each we store color information and the 3D position relative to an arbitrary origin.</p>
                <img src="./img/scan.JPG" />

                <h3>Coarse matching</h3>
                <p>
                    In cases where the buildings are too big and for performance reasoning we sometimes recommend preceeding our 3D
                    matching algorithms with a basic machine learning model that allows us to to recognize first if the
                    user is in the right area, before starting to scan. For this, right now, we train on a 256x256 video of the
                    location, for which we only store the trained model on the server. The user will send images to the trained model to
                    get the classification.
                </p>
            </div>

            <div class="sdk-reference" style="display: none">
                <h2>Unity Package Reference</h2>

                <h3 id="insidar-manager"><u>InsidAR Manager</u></h3>
                <p>Here you can setup the main variables</p>
                <h4>serverURL</h4>
                <h4>apiKey</h4>

                <h3 id="scan-manager"><u>Scan Manager</u></h3>
                <p>This class manages the scan workflow</p>
                <h4>numberOfPoints</h4>
                <h4>groundHeight</h4>
                <h4>SwitchShouldScan()</h4>
                <p>Switches between scanning and not scanning states. While this is opened the scan keeps growing.</p>
                <h4>ClearScan()</h4>
                <p>Deletes all scan points</p>

                <h3 id="network-manager"><u>NetworkManager</u></h3>
                <p>Methods for calling most API endpoints.</p>
                <h4>OffsetPositionDomain offsetPosition</h4>
                <p>Object where the relative position/rotation from parent scan is stored. This is usually setup after response from calling MatchScan().</p>
                <h4>public delegate void OffsetPositionDomain(string response)</h4>
                <h4>void MatchScan(string scanName)</h4>
                <p>The server can store multiple scans identified by the scanName. Triggers OnScanMatched and sets offsetPosition.</p>
                <h4>void GetScanNames(ProcessResponse callback)</h4>
                <p>Get a list with names of all your scans stored on the server.</p>
                <h4>DownloadAnchors(string scanName)</h4>
                <p>Get positions of all stored anchors relative to the AR camera</p>
                <h4>Upload Anchors(string scanName, List&lt;Vector3&lt; positions)</h4>
                <p>Upload anchors on server</p>

                <h3 id="process-response"><u>ProcessResponse</u></h3>
            </div>
        </div>

        <footer>
            <small>Made with <span class="heart">❤</span> in Iasi, Romania</small>
        </footer>

        <script>
            switchView('how-it-works');
        </script>
    </body>
</html>
